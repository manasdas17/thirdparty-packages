/* Copyright (c) 2005, 2006, 2008 by CodeSourcery.  All rights reserved.

   This file is available for license from CodeSourcery, Inc. under the terms
   of a commercial license and under the GPL.  It is not part of the VSIPL++
   reference implementation and is not available under the BSD license.
*/
/** @file    tests/tensor.cpp
    @author  Stefan Seefeld
    @date    2005-04-26
    @brief   VSIPL++ Library: Unit tests for Tensors.
*/

#ifndef ILLEGALCASE
#  define ILLEGALCASE 0
#endif

/***********************************************************************
  Included Files
***********************************************************************/

#include <iostream>
#include <cassert>
#include <vsip/initfin.hpp>
#include <vsip/support.hpp>
#include <vsip/tensor.hpp>
#include <vsip_csl/test.hpp>

using namespace std;
using namespace vsip;
using namespace vsip_csl;


template <typename T,
	  typename Block>
inline
std::ostream&
operator<<(
  std::ostream&		       out,
  vsip::const_Tensor<T, Block> tensor)
  VSIP_NOTHROW
{
  for (vsip::index_type i=0; i<tensor.size(); ++i)
    out << "  " << i << ": " << tensor.get(i) << "\n";
  return out;
}

/***********************************************************************
  Definitions - Utility Functions
***********************************************************************/

// check_size -- check the reported size of a tensor against
//               expected size

template <typename T,
	  typename Block>
void
check_size(const_Tensor<T, Block> tensor,
	   length_type i, length_type j, length_type k)
{
  test_assert(tensor.size() == i * j * k);
  test_assert(tensor.size(0) == i);
  test_assert(tensor.size(1) == j);
  test_assert(tensor.size(2) == k);
}



// fill_tensor -- fill a tensor with a sequence of values.
//
// Values are generated with a slope of kk.

template <typename T,
	  typename Block>
void
fill_tensor(Tensor<T, Block> tensor, int kk)
{
  for (index_type i = 0; i < tensor.size(0); ++i)
    for (index_type j = 0; j < tensor.size(1); ++j)
      for (index_type k = 0; k < tensor.size(2); ++k)
	tensor.put(i, j, k, T(kk * i * j * k + 1));
}



// fill_block -- fill a block with sequence of values.
//
// Values are generated with a slope of kk.

template <typename Block>
void
fill_block(Block& blk, int kk)
{
  typedef typename Block::value_type T;

  for (index_type i = 0; i < blk.size(3, 0); ++i)
    for (index_type j = 0; j < blk.size(3, 1); ++j)
      for (index_type k = 0; k < blk.size(3, 2); ++k)
	blk.put(i, j, k, T(kk * i * j * k + 1));
}



// test_tensor -- test values in tensor against sequence.
//
// Asserts that tensor values match those generated by a call to
// fill_tensor or fill_block with the same kk value.

template <typename T,
	  typename Block>
void
test_tensor(const_Tensor<T, Block> tensor, int kk)
{
  for (index_type i = 0; i < tensor.size(0); ++i)
    for (index_type j = 0; j < tensor.size(1); ++j)
      for (index_type k = 0; k < tensor.size(2); ++k)
	test_assert(equal(tensor.get(i, j, k), T(kk * i * j * k + 1)));
}



// check_tensor -- check values in tensor against sequence.
//
// Checks that tensor values match those generated by a call to
// fill_tensor or fill_block with the same k value.  Rather than
// triggering test_assertion failure, check_tensor returns a boolean
// pass/fail that can be used to cause an test_assertion failure in
// the caller.

template <typename T,
	  typename Block>
bool
check_tensor(const_Tensor<T, Block> tensor, int kk)
{
  for (index_type i = 0; i < tensor.size(0); ++i)
    for (index_type j = 0; j < tensor.size(1); ++j)
      for (index_type k = 0; k < tensor.size(2); ++k)
	if (!equal(tensor.get(i, j, k), T(kk * i * j * k + 1)))
	  return false;
  return true;
}



// check_not_alias -- check that two views are not aliased.
//
// Changes made to one should not effect the other.

template <template <typename, typename> class View1,
	  template <typename, typename> class View2,
	  typename T1,
	  typename T2,
	  typename Block1,
	  typename Block2>
void
check_not_alias(
  View1<T1, Block1>& tensor1,
  View2<T2, Block2>& tensor2)
{
  fill_block(tensor1.block(), 2);
  fill_block(tensor2.block(), 3);

  // Make sure that updates to tensor2 do not affect tensor1.
  test_assert(check_tensor(tensor1, 2));

  // And visa-versa.
  fill_block(tensor1.block(), 4);
  test_assert(check_tensor(tensor2, 3));
}



// check_alias -- check that two views are aliased.
//
// Changes made to one should effect the other.

template <template <typename, typename> class View1,
	  template <typename, typename> class View2,
	  typename T1,
	  typename T2,
	  typename Block1,
	  typename Block2>
void
check_alias(
  View1<T1, Block1>& tensor1,
  View2<T2, Block2>& tensor2)
{
  fill_block(tensor1.block(), 2);
  test_assert(check_tensor(tensor1, 2));
  test_assert(check_tensor(tensor2, 2));

  fill_block(tensor2.block(), 3);
  test_assert(check_tensor(tensor1, 3));
  test_assert(check_tensor(tensor2, 3));
}



/***********************************************************************
  Definitions - Tensor Test Cases.
***********************************************************************/

// -------------------------------------------------------------------- //
// test cases for get/put.

// tc_get -- test a tensor's get() member function.

template <typename                            T,
	  template <typename, typename> class View>
void
tc_get(length_type i, length_type j, length_type k)
{
  View<T, Dense<3, T> > tensor(i, j, k);

  check_size(tensor, i, j, k);
  fill_block(tensor.block(), 2);
  test_tensor(tensor, 2);
}



template <typename T>
void
test_get_type(length_type i, length_type j, length_type k)
{
  tc_get<T,       Tensor>(i, j, k);
  tc_get<T, const_Tensor>(i, j, k);
}


void test_get(length_type i, length_type j, length_type k)
{
  test_get_type<scalar_f>(i, j, k);
  test_get_type<cscalar_f>(i, j, k);
  test_get_type<int>(i, j, k);
  // test_get_type<short>(i, j, k);
}


// -------------------------------------------------------------------- //
// test cases for get/put.

// tc_getput -- test a tensor's get() and put() member functions.

template <typename                            T,
	  template <typename, typename> class View>
void
tc_getput(length_type i, length_type j, length_type k)
{
  View<T, Dense<3, T> > tensor(i, j, k);

  check_size(tensor, i, j, k);
  fill_tensor(tensor, 2);
  test_tensor(tensor, 2);
}



template <typename T>
void
test_getput_type(length_type i, length_type j, length_type k)
{
  tc_getput<T,       Tensor>(i, j, k);
#if (ILLEGALCASE == 1)
  // const_Tensor should not provide put()
  tc_getput<T, const_Tensor>(i, j, k);
#endif
}



void test_getput(length_type i, length_type j, length_type k)
{
  test_getput_type<scalar_f>(i, j, k);
  test_getput_type<cscalar_f>(i, j, k);
  test_getput_type<int>(i, j, k);
  // test_getput_type<short>(i, j, k);
}

// -------------------------------------------------------------------- //
// test cases for copy constructor.

template <typename T1,
	  typename T2,
	  template <typename, typename> class View1,
	  template <typename, typename> class View2>
void
tc_copy_cons(length_type i, length_type j, length_type k, int v)
{
  View1<T1, Dense<3, T1> > tensor1(i, j, k);

  fill_block(tensor1.block(), v);

  View2<T2, Dense<3, T2> > tensor2(tensor1);

  test_tensor(tensor2, v);

  check_alias(tensor1, tensor2);
}



template <typename T1,
	  typename T2>
void
test_copy_cons_type(length_type i, length_type j, length_type k, int v)
{
  tc_copy_cons<T1, T2,       Tensor,       Tensor>(i, j, k, v);
  tc_copy_cons<T1, T2,       Tensor, const_Tensor>(i, j, k, v);
  tc_copy_cons<T1, T2, const_Tensor, const_Tensor>(i, j, k, v);

#if (ILLEGALCASE == 2)
  // It should be illegal to construct a Tensor from a const_Tensor.
  tc_copy_cons<T1, T2, const_Tensor,       Tensor>(i, j, k, v);
#endif
}



void
test_copy_cons(length_type i, length_type j, length_type k, int v)
{
  test_copy_cons_type<float, float>(i, j, k, v);
  // tc_copy_cons_set<  int,   int>(i, j, k, v);
}

// -------------------------------------------------------------------- //
// test cases for assignment

template <typename T1,
	  typename T2,
	  template <typename, typename> class View1,
	  template <typename, typename> class View2>
void
tc_assign(length_type i, length_type j, length_type k, int v)
{
  View1<T1, Dense<3, T1> > tensor1(i, j, k);
  View2<T2, Dense<3, T2> > tensor2(i, j, k);

  fill_block(tensor1.block(), v);

  tensor2 = tensor1;

  test_assert(check_tensor(tensor2, v));

  check_not_alias(tensor1, tensor2);
}



template <typename T1,
	  typename T2>
void
test_assign_type(length_type i, length_type j, length_type k, int v)
{
  tc_assign<T1, T2, Tensor,       Tensor>(i, j, k, v);
  tc_assign<T1, T2, const_Tensor, Tensor>(i, j, k, v);

#if (ILLEGALCASE == 3)
  tc_assign<T1, T2, Tensor,       const_Tensor>(i, j, k, v);
#endif
#if (ILLEGALCASE == 4)
  tc_assign<T1, T2, const_Tensor, const_Tensor>(i, j, k, v);
#endif
}



void
test_assign(length_type i, length_type j, length_type k, int v)
{
  test_assign_type<float, float>(i, j, k, v);
}

// -------------------------------------------------------------------- //
// test cases for funcall

// tc_sum_const -- sum values in a const_Tensor.

template <typename T,
	  typename Block>
T
tc_sum_const(const_Tensor<T, Block> tensor)
{
  T sumval = T();
  for (index_type i = 0; i < tensor.size(0); ++i)
    for (index_type j = 0; j < tensor.size(1); ++j)
      for (index_type k = 0; k < tensor.size(2); ++k)
	sumval += tensor.get(i, j, k);
  return sumval;
}



// tc_sum -- sum values in a Tensor.

template <typename T,
	  typename Block>
T
tc_sum(Tensor<T, Block> tensor)
{
  T sumval = T();
  for (index_type i = 0; i < tensor.size(0); ++i)
    for (index_type j = 0; j < tensor.size(1); ++j)
      for (index_type k = 0; k < tensor.size(2); ++k)
	sumval += tensor.get(i, j, k);
  return sumval;
}



// tc_call_sum_const -- create View, pass it to tc_sum_const,
//                      check result.
template <typename T,
	  template <typename, typename> class View>
void
tc_call_sum_const(length_type i, length_type j, length_type k, int v)
{
  View<T, Dense<3, T> > tensor1(i, j, k);

  fill_block(tensor1.block(), v);
  T sum = tc_sum_const(tensor1);

  test_assert(equal(sum, T(v*i*(i-1)*j*(j-1)*k*(k-1)/8+i*j*k)));
}



// tc_call_sum -- create View, pass it to tc_sum, check result.

template <typename T,
	  template <typename, typename> class View>
void
tc_call_sum(length_type i, length_type j, length_type k, int v)
{
  View<T, Dense<3, T> > tensor1(i, j, k);

  fill_block(tensor1.block(), v);
  T sum = tc_sum(tensor1);

  test_assert(equal(sum, T(v*i*(i-1)*j*(j-1)*k*(k-1)/8+i*j*k)));
}



// test_call -- test that Tensor and const_Tensor can be passed
//              as arguments to functions.

void
test_call(length_type i, length_type j, length_type k, int v)
{
  tc_call_sum_const<float, const_Tensor>(i, j, k, v);
  tc_call_sum_const<float,       Tensor>(i, j, k, v);

#if (ILLEGALCASE == 5)
  // should not be able to pass a const_Tensor to a routine
  // expecting a Tensor.
  tc_call_sum<float, const_Tensor>(i, j, k, v);
#endif
  tc_call_sum<float,       Tensor>(i, j, k, v);
}

// -------------------------------------------------------------------- //
// test cases for returning a view from a function.

// Generate a view/block of length LEN, with element 0 initialized
// to VAL.

template <template <typename, typename> class View,
	  typename			      T,
	  typename			      Block>
View<T, Block>
return_view(length_type i, length_type j, length_type k, T val)
{
  Block* blk = new Block(Domain<3>(i, j, k));
  blk->put(0, 0, 0, val);
  View<T, Block> vec(*blk);
  blk->decrement_count();

  return vec;
}



// Assign a view from the value of a function returning a view.

template <typename T,
	  template <typename, typename> class View1,
	  template <typename, typename> class View2>
void
tc_assign_return(length_type i, length_type j, length_type k, T val)
{
  typedef Dense<3, T> block_type;
  View1<T, block_type> tensor1(i, j, k, T());

  test_assert(tensor1.get(0, 0, 0) != val || val == T());

  tensor1 = return_view<View2, T, block_type>(i, j, k, val);

  test_assert(tensor1.get(0, 0, 0) == val);
}



// Construct a view from the value of a function returning a view.

template <typename T,
	  template <typename, typename> class View1,
	  template <typename, typename> class View2>
void
tc_cons_return(length_type i, length_type j, length_type k, T val)
{
  typedef Dense<3, T> block_type;

  View1<T, block_type> vec1(return_view<View2, T, block_type>(i, j, k, val));

  test_assert(vec1.get(0, 0, 0) == val);
}



void
test_return()
{
  tc_assign_return<float,       Tensor,       Tensor>(10, 10, 10, 1.0);
  tc_assign_return<float,       Tensor, const_Tensor>(10, 10, 10, 1.0);

  // These cases are illegal: you cannot assign to a const_Tensor
#if ILLEGALCASE == 6
  tc_assign_return<float, const_Tensor, const_Tensor>(10, 10, 10, 1.0);
#endif
#if ILLEGALCASE == 7
  tc_assign_return<float, const_Tensor,       Tensor>(10, 10, 10, 1.0);
#endif

  tc_cons_return<float,       Tensor,       Tensor>(10, 10, 10, 1.0);
  tc_cons_return<float,       Tensor, const_Tensor>(10, 10, 10, 1.0);
  tc_cons_return<float, const_Tensor,       Tensor>(10, 10, 10, 1.0);
  tc_cons_return<float, const_Tensor, const_Tensor>(10, 10, 10, 1.0);
}


template <typename T>
void
tc_subview(Domain<3> const& dom, Domain<3> const& sub)
{
  Tensor<T> view(dom[0].length(), dom[1].length(), dom[2].length());

  fill_tensor(view, 2);

  typename Tensor<T>::subview_type        subv = view(sub);
  typename Tensor<T>::const_subview_type csubv = view.get(sub);

  for (index_type i = 0; i < sub[0].size(); ++i)
    for (index_type j = 0; j < sub[1].size(); ++j)
      for (index_type k = 0; k < sub[2].size(); ++k)
      {
	index_type parent_i = sub[0].impl_nth(i);
	index_type parent_j = sub[1].impl_nth(j);
	index_type parent_k = sub[2].impl_nth(k);

	test_assert(view.get(parent_i, parent_j, parent_k) ==  subv.get(i, j, k));
	test_assert(view.get(parent_i, parent_j, parent_k) == csubv.get(i, j, k));

	view.put(parent_i, parent_j, parent_k,
		 view.get(parent_i, parent_j, parent_k) + T(1));

	test_assert(view.get(parent_i, parent_j, parent_k) ==  subv.get(i, j, k));
	test_assert(view.get(parent_i, parent_j, parent_k) == csubv.get(i, j, k));

	subv.put(i, j, k, subv.get(i, j, k) + T(1));

	test_assert(view.get(parent_i, parent_j, parent_k) ==  subv.get(i, j, k));
	test_assert(view.get(parent_i, parent_j, parent_k) == csubv.get(i, j, k));
      }
}


void
test_subview()
{
  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(0, 1, 3), Domain<1>(10), Domain<1>(10)));
  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(5, 1, 3), Domain<1>(10), Domain<1>(10)));
  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(0, 2, 3), Domain<1>(10), Domain<1>(10)));
  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(5, 2, 3), Domain<1>(10), Domain<1>(10)));

  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(10), Domain<1>(0, 1, 3), Domain<1>(10)));
  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(10), Domain<1>(5, 1, 3), Domain<1>(10)));
  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(10), Domain<1>(0, 2, 3), Domain<1>(10)));
  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(10), Domain<1>(5, 2, 3), Domain<1>(10)));

  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(10), Domain<1>(10), Domain<1>(0, 1, 3)));
  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(10), Domain<1>(10), Domain<1>(5, 1, 3)));
  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(10), Domain<1>(10), Domain<1>(0, 2, 3)));
  tc_subview<float>(Domain<3>(10, 10, 10),
		    Domain<3>(Domain<1>(10), Domain<1>(10), Domain<1>(5, 2, 3)));

  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(0, 1, 3),
					Domain<1>(10),
					Domain<1>(10)));
  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(5, 1, 3),
					Domain<1>(10),
					Domain<1>(10)));
  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(0, 2, 3),
					Domain<1>(10),
					Domain<1>(10)));
  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(5, 2, 3),
					Domain<1>(10),
					Domain<1>(10)));

  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(10),
					Domain<1>(0, 1, 3),
					Domain<1>(10)));
  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(10),
					Domain<1>(5, 1, 3),
					Domain<1>(10)));
  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(10),
					Domain<1>(0, 2, 3),
					Domain<1>(10)));
  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(10),
					Domain<1>(10),
					Domain<1>(5, 2, 3)));

  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(10),
					Domain<1>(10),
					Domain<1>(0, 1, 3)));
  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(10),
					Domain<1>(10),
					Domain<1>(5, 1, 3)));
  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(10),
					Domain<1>(10),
					Domain<1>(0, 2, 3)));
  tc_subview<complex<float> >(Domain<3>(10, 10, 10),
			      Domain<3>(Domain<1>(10),
					Domain<1>(10),
					Domain<1>(5, 2, 3)));

  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(0, 1, 3), Domain<1>(10), Domain<1>(10)));
  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(5, 1, 3), Domain<1>(10), Domain<1>(10)));
  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(0, 2, 3), Domain<1>(10), Domain<1>(10)));
  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(5, 2, 3), Domain<1>(10), Domain<1>(10)));
  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(10), Domain<1>(0, 1, 3), Domain<1>(10)));
  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(10), Domain<1>(5, 1, 3), Domain<1>(10)));
  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(10), Domain<1>(0, 2, 3), Domain<1>(10)));
  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(10), Domain<1>(5, 2, 3), Domain<1>(10)));
  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(10), Domain<1>(10), Domain<1>(0, 1, 3)));
  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(10), Domain<1>(10), Domain<1>(5, 1, 3)));
  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(10), Domain<1>(10), Domain<1>(0, 2, 3)));
  tc_subview<int>(Domain<3>(10, 10, 10),
		  Domain<3>(Domain<1>(10), Domain<1>(10), Domain<1>(5, 2, 3)));
}

void
test_complex()
{
  typedef Tensor<std::complex<double> > CTensor;
  CTensor cm(2, 2, 2, 3.);
  CTensor::realview_type rm = cm.real();
  CTensor::imagview_type im = cm.imag();
  CTensor::const_realview_type crm = const_cast<CTensor const&>(cm).real();
  CTensor::const_imagview_type cim = const_cast<CTensor const&>(cm).imag();
  cm.put(0, 0, 0, 5.);
  cm.put(1, 0, 0, 5.);
  cm.put(0, 1, 0, 5.);
  cm.put(1, 1, 0, 5.);
  cm.put(0, 0, 1, 5.);
  cm.put(1, 0, 1, 5.);
  cm.put(0, 1, 1, 5.);
  cm.put(1, 1, 1, 5.);
  test_assert(equal(40., tc_sum(rm)));
  test_assert(equal(0., tc_sum(im)));
  test_assert(equal(40., tc_sum_const(crm)));
  test_assert(equal(0., tc_sum_const(cim)));
  rm.put(0, 0, 0, 0.);
  rm.put(1, 0, 0, 0.);
  rm.put(0, 1, 0, 0.);
  rm.put(1, 1, 0, 0.);
  im.put(0, 0, 0, 5.);
  im.put(1, 0, 0, 5.);
  im.put(0, 1, 0, 5.);
  im.put(1, 1, 0, 5.);
  test_assert(equal(20., tc_sum(rm)));
  test_assert(equal(20., tc_sum(im)));
  test_assert(equal(20., tc_sum_const(crm)));
  test_assert(equal(20., tc_sum_const(cim)));
}

void
test_const_complex()
{
  typedef const_Tensor<std::complex<double> > CTensor;
  CTensor cm(2, 2, 2, 5.);
  CTensor::const_realview_type crm = cm.real();
  CTensor::const_imagview_type cim = cm.imag();
  test_assert(equal(40., tc_sum_const(crm)));
  test_assert(equal(0., tc_sum_const(cim)));
}

void
test_subvector0()
{
  Tensor<double> m(2, 2, 2, 3.);
  Tensor<double>::subvector<1, 2>::type v0 = m(Domain<1>(2), 0, 0);
  Tensor<double> const &cm = const_cast<Tensor<double> const&>(m);
  Tensor<double>::subvector<1, 2>::const_type cv0 = cm(Domain<1>(2), 1, 1);
  test_assert(equal(3., v0.get(0)));
  test_assert(equal(3., v0.get(1)));
  test_assert(equal(3., cv0.get(0)));
  test_assert(equal(3., cv0.get(1)));
  m.put(0, 0, 0, 0.);
  m.put(1, 0, 0, 1.);
  m.put(0, 1, 0, 2.);
  m.put(1, 1, 0, 3.);
  m.put(0, 0, 1, 4.);
  m.put(1, 0, 1, 5.);
  m.put(0, 1, 1, 6.);
  m.put(1, 1, 1, 7.);
  test_assert(equal(0., v0.get(0)));
  test_assert(equal(1., v0.get(1)));
  test_assert(equal(6., cv0.get(0)));
  test_assert(equal(7., cv0.get(1)));
  v0.put(0, 0.);
  v0.put(1, 0.);
  test_assert(equal(0., m.get(0, 0, 0)));
  test_assert(equal(0., m.get(1, 0, 0)));
  test_assert(equal(6., cv0.get(0)));
  test_assert(equal(7., cv0.get(1)));
}

void
test_const_subvector0()
{
  const_Tensor<double> t(2, 2, 2, 3.);
  const_Tensor<double>::subvector<1, 2>::const_type cv1 = t(Domain<1>(2), 0, 0);
  const_Tensor<double>::subvector<1, 2>::const_type cv2 = t(Domain<1>(2), 1, 1);
  test_assert(equal(3., cv1.get(0)));
  test_assert(equal(3., cv1.get(1)));
  test_assert(equal(3., cv2.get(0)));
  test_assert(equal(3., cv2.get(1)));
}

void
test_subvector1()
{
  Tensor<double> m(2, 2, 2, 3.);
  Tensor<double>::subvector<0, 2>::type v0 = m(0, Domain<1>(2), 0);
  Tensor<double> const &cm = const_cast<Tensor<double> const&>(m);
  Tensor<double>::subvector<0, 2>::const_type cv0 = cm(1, Domain<1>(2), 1);
  test_assert(equal(3., v0.get(0)));
  test_assert(equal(3., v0.get(1)));
  test_assert(equal(3., cv0.get(0)));
  test_assert(equal(3., cv0.get(1)));
  m.put(0, 0, 0, 0.);
  m.put(1, 0, 0, 1.);
  m.put(0, 1, 0, 2.);
  m.put(1, 1, 0, 3.);
  m.put(0, 0, 1, 4.);
  m.put(1, 0, 1, 5.);
  m.put(0, 1, 1, 6.);
  m.put(1, 1, 1, 7.);
  test_assert(equal(0., v0.get(0)));
  test_assert(equal(2., v0.get(1)));
  test_assert(equal(5., cv0.get(0)));
  test_assert(equal(7., cv0.get(1)));
  v0.put(0, 0.);
  v0.put(1, 0.);
  test_assert(equal(0., m.get(0, 0, 0)));
  test_assert(equal(0., m.get(0, 1, 0)));
  test_assert(equal(5., cv0.get(0)));
  test_assert(equal(7., cv0.get(1)));
}

void
test_const_subvector1()
{
  const_Tensor<double> t(2, 2, 2, 3.);
  const_Tensor<double>::subvector<0, 2>::const_type cv1 = t(0, Domain<1>(2), 0);
  const_Tensor<double>::subvector<0, 2>::const_type cv2 = t(1, Domain<1>(2), 1);
  test_assert(equal(3., cv1.get(0)));
  test_assert(equal(3., cv1.get(1)));
  test_assert(equal(3., cv2.get(0)));
  test_assert(equal(3., cv2.get(1)));
}

void
test_subvector2()
{
  Tensor<double> m(2, 2, 2, 3.);
  Tensor<double>::subvector<0, 1>::type v0 = m(0, 0, Domain<1>(2));
  Tensor<double> const &cm = const_cast<Tensor<double> const&>(m);
  Tensor<double>::subvector<0, 1>::const_type cv0 = cm(1, 1, Domain<1>(2));
  test_assert(equal(3., v0.get(0)));
  test_assert(equal(3., v0.get(1)));
  test_assert(equal(3., cv0.get(0)));
  test_assert(equal(3., cv0.get(1)));
  m.put(0, 0, 0, 0.);
  m.put(1, 0, 0, 1.);
  m.put(0, 1, 0, 2.);
  m.put(1, 1, 0, 3.);
  m.put(0, 0, 1, 4.);
  m.put(1, 0, 1, 5.);
  m.put(0, 1, 1, 6.);
  m.put(1, 1, 1, 7.);
  test_assert(equal(0., v0.get(0)));
  test_assert(equal(4., v0.get(1)));
  test_assert(equal(3., cv0.get(0)));
  test_assert(equal(7., cv0.get(1)));
  v0.put(0, 0.);
  v0.put(1, 0.);
  test_assert(equal(0., m.get(0, 0, 0)));
  test_assert(equal(0., m.get(0, 0, 1)));
  test_assert(equal(3., cv0.get(0)));
  test_assert(equal(7., cv0.get(1)));
}

void
test_const_subvector2()
{
  const_Tensor<double> t(2, 2, 2, 3.);
  const_Tensor<double>::subvector<0, 1>::const_type cv1 = t(0, 0, Domain<1>(2));
  const_Tensor<double>::subvector<0, 1>::const_type cv2 = t(1, 1, Domain<1>(2));
  test_assert(equal(3., cv1.get(0)));
  test_assert(equal(3., cv1.get(1)));
  test_assert(equal(3., cv2.get(0)));
  test_assert(equal(3., cv2.get(1)));
}

void
test_submatrix0()
{
  Tensor<double> t(2, 2, 2, 3.);
  Tensor<double>::submatrix<0>::type m0 = t(0, Domain<1>(2), Domain<1>(2));
  Tensor<double> const &ct = const_cast<Tensor<double> const&>(t);
  Tensor<double>::submatrix<0>::const_type cm0 = ct(1,
						    Domain<1>(2),
						    Domain<1>(2));
  test_assert(equal(3., m0.get(0, 0)));
  test_assert(equal(3., m0.get(1, 0)));
  test_assert(equal(3., m0.get(0, 1)));
  test_assert(equal(3., m0.get(1, 1)));
  test_assert(equal(3., cm0.get(0, 0)));
  test_assert(equal(3., cm0.get(1, 0)));
  test_assert(equal(3., cm0.get(0, 1)));
  test_assert(equal(3., cm0.get(1, 1)));
  t.put(0, 0, 0, 0.);
  t.put(1, 0, 0, 1.);
  t.put(0, 1, 0, 2.);
  t.put(1, 1, 0, 3.);
  t.put(0, 0, 1, 4.);
  t.put(1, 0, 1, 5.);
  t.put(0, 1, 1, 6.);
  t.put(1, 1, 1, 7.);
  test_assert(equal(0., m0.get(0, 0)));
  test_assert(equal(2., m0.get(1, 0)));
  test_assert(equal(4., m0.get(0, 1)));
  test_assert(equal(6., m0.get(1, 1)));
  test_assert(equal(1., cm0.get(0, 0)));
  test_assert(equal(3., cm0.get(1, 0)));
  test_assert(equal(5., cm0.get(0, 1)));
  test_assert(equal(7., cm0.get(1, 1)));
  m0.put(0, 0, 0.);
  m0.put(1, 0, 0.);
  test_assert(equal(0., t.get(0, 0, 0)));
  test_assert(equal(0., t.get(0, 1, 0)));
}

void
test_const_submatrix0()
{
  const_Tensor<double> ct(2, 2, 2, 3.);
  const_Tensor<double>::submatrix<0>::const_type cm1 = ct(0, 
							  Domain<1>(2), 
							  Domain<1>(2));
  const_Tensor<double>::submatrix<0>::const_type cm2 = ct(1,
							  Domain<1>(2),
							  Domain<1>(2));
  test_assert(equal(3., cm1.get(0, 0)));
  test_assert(equal(3., cm1.get(1, 0)));
  test_assert(equal(3., cm2.get(0, 0)));
  test_assert(equal(3., cm2.get(1, 0)));
}

void
test_submatrix1()
{
  Tensor<double> t(2, 2, 2, 3.);
  Tensor<double>::submatrix<1>::type m0 = t(Domain<1>(2), 0, Domain<1>(2));
  Tensor<double> const &ct = const_cast<Tensor<double> const&>(t);
  Tensor<double>::submatrix<1>::const_type cm0 = ct(Domain<1>(2),
						    1, 
						    Domain<1>(2));
  test_assert(equal(3., m0.get(0, 0)));
  test_assert(equal(3., m0.get(1, 0)));
  test_assert(equal(3., m0.get(0, 1)));
  test_assert(equal(3., m0.get(1, 1)));
  test_assert(equal(3., cm0.get(0, 0)));
  test_assert(equal(3., cm0.get(1, 0)));
  test_assert(equal(3., cm0.get(0, 1)));
  test_assert(equal(3., cm0.get(1, 1)));
  t.put(0, 0, 0, 0.);
  t.put(1, 0, 0, 1.);
  t.put(0, 1, 0, 2.);
  t.put(1, 1, 0, 3.);
  t.put(0, 0, 1, 4.);
  t.put(1, 0, 1, 5.);
  t.put(0, 1, 1, 6.);
  t.put(1, 1, 1, 7.);
  test_assert(equal(0., m0.get(0, 0)));
  test_assert(equal(1., m0.get(1, 0)));
  test_assert(equal(4., m0.get(0, 1)));
  test_assert(equal(5., m0.get(1, 1)));
  test_assert(equal(2., cm0.get(0, 0)));
  test_assert(equal(3., cm0.get(1, 0)));
  test_assert(equal(6., cm0.get(0, 1)));
  test_assert(equal(7., cm0.get(1, 1)));
  m0.put(0, 0, 0.);
  m0.put(1, 0, 0.);
  test_assert(equal(0., t.get(0, 0, 0)));
  test_assert(equal(0., t.get(1, 0, 0)));
}

void
test_const_submatrix1()
{
  const_Tensor<double> ct(2, 2, 2, 3.);
  const_Tensor<double>::submatrix<1>::const_type cm1 = ct(Domain<1>(2), 
							  0,
							  Domain<1>(2));
  const_Tensor<double>::submatrix<1>::const_type cm2 = ct(Domain<1>(2),
							  1,
							  Domain<1>(2));
  test_assert(equal(3., cm1.get(0, 0)));
  test_assert(equal(3., cm1.get(1, 0)));
  test_assert(equal(3., cm2.get(0, 0)));
  test_assert(equal(3., cm2.get(1, 0)));
}

void
test_submatrix2()
{
  Tensor<double> t(2, 2, 2, 3.);
  Tensor<double>::submatrix<2>::type m0 = t(Domain<1>(2), Domain<1>(2), 0);
  Tensor<double> const &ct = const_cast<Tensor<double> const&>(t);
  Tensor<double>::submatrix<2>::const_type cm0 = ct(Domain<1>(2),
						    Domain<1>(2),
						    1);
  test_assert(equal(3., m0.get(0, 0)));
  test_assert(equal(3., m0.get(1, 0)));
  test_assert(equal(3., m0.get(0, 1)));
  test_assert(equal(3., m0.get(1, 1)));
  test_assert(equal(3., cm0.get(0, 0)));
  test_assert(equal(3., cm0.get(1, 0)));
  test_assert(equal(3., cm0.get(0, 1)));
  test_assert(equal(3., cm0.get(1, 1)));
  t.put(0, 0, 0, 0.);
  t.put(1, 0, 0, 1.);
  t.put(0, 1, 0, 2.);
  t.put(1, 1, 0, 3.);
  t.put(0, 0, 1, 4.);
  t.put(1, 0, 1, 5.);
  t.put(0, 1, 1, 6.);
  t.put(1, 1, 1, 7.);
  test_assert(equal(0., m0.get(0, 0)));
  test_assert(equal(1., m0.get(1, 0)));
  test_assert(equal(2., m0.get(0, 1)));
  test_assert(equal(3., m0.get(1, 1)));
  test_assert(equal(4., cm0.get(0, 0)));
  test_assert(equal(5., cm0.get(1, 0)));
  test_assert(equal(6., cm0.get(0, 1)));
  test_assert(equal(7., cm0.get(1, 1)));
  m0.put(0, 0, 0.);
  m0.put(1, 0, 0.);
  test_assert(equal(0., t.get(0, 0, 0)));
  test_assert(equal(0., t.get(1, 0, 0)));
}

void
test_const_submatrix2()
{
  const_Tensor<double> ct(2, 2, 2, 3.);
  const_Tensor<double>::submatrix<2>::const_type cm1 = ct(Domain<1>(2), 
							  Domain<1>(2),
							  0);
  const_Tensor<double>::submatrix<2>::const_type cm2 = ct(Domain<1>(2),
							  Domain<1>(2),
							  1);
  test_assert(equal(3., cm1.get(0, 0)));
  test_assert(equal(3., cm1.get(1, 0)));
  test_assert(equal(3., cm2.get(0, 0)));
  test_assert(equal(3., cm2.get(1, 0)));
}

#define VSIP_TEST_ELEMENTWISE_SCALAR(x, op, y)    \
{                                                 \
  Tensor<int> m(1, 1, 1, x);		          \
  Tensor<int> &m1 = (m op y);		          \
  int r = x;                                      \
  r op y;                                         \
  test_assert(&m1 == &m && equal(m1.get(0, 0, 0), r)); \
}

#define VSIP_TEST_ELEMENTWISE_TENSOR(x, op, y)    \
{                                                 \
  Tensor<int> m(1, 1, 1, x);		          \
  Tensor<int> n(1, 1, 1, y);		          \
  Tensor<int> &m1 = (m op n);		          \
  int r = x;                                      \
  r op y;                                         \
  test_assert(&m1 == &m && equal(m1.get(0, 0, 0), r)); \
}

int
main(int argc, char** argv)
{
  vsip::vsipl init(argc, argv);

  test_get(10, 10, 10);
  test_getput(10, 10, 10);

  test_copy_cons(10, 10, 10, 3);
  test_assign(10, 10, 10, 3);

  test_call(10, 10, 10, 3);

  test_subview();

  test_complex();
  test_const_complex();

  VSIP_TEST_ELEMENTWISE_SCALAR(4, +=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, -=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, *=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, /=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, &=, 3)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, &=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, |=, 3)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, |=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, ^=, 3)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, ^=, 2)

  VSIP_TEST_ELEMENTWISE_TENSOR(4, +=, 2)
  VSIP_TEST_ELEMENTWISE_TENSOR(4, -=, 2)
  VSIP_TEST_ELEMENTWISE_TENSOR(4, *=, 2)
  VSIP_TEST_ELEMENTWISE_TENSOR(4, /=, 2)
  VSIP_TEST_ELEMENTWISE_TENSOR(4, &=, 3)
  VSIP_TEST_ELEMENTWISE_TENSOR(4, &=, 2)
  VSIP_TEST_ELEMENTWISE_TENSOR(4, |=, 3)
  VSIP_TEST_ELEMENTWISE_TENSOR(4, |=, 2)
  VSIP_TEST_ELEMENTWISE_TENSOR(4, ^=, 3)
  VSIP_TEST_ELEMENTWISE_TENSOR(4, ^=, 2)

  test_subvector0();
  test_const_subvector0();
  test_subvector1();
  test_const_subvector1();
  test_subvector2();
  test_const_subvector2();

  test_submatrix0();
  test_const_submatrix0();
  test_submatrix1();
  test_const_submatrix1();
  test_submatrix2();
  test_const_submatrix2();
}
