#! /usr/bin/perl
# --------------------------------------------------------------------- #
# scripts/datasheet.pl -- VSIPL++ Datasheet Script			#
# (31 Jul 07) Jules Bergmann						#
# --------------------------------------------------------------------- #

use strict;

my $sheet    = 0;

# --------------------------------------------------------------------- #
# read_dat -- read .dat file generated by char.pl
sub read_dat {
   my ($db, $inf) = @_;

   open(IN, $inf) || die "Can't read '$inf': $!\n";

   my $line;
   my @line;

   while (<IN>) {
      chomp($_);
      @line = split(',', $_);
      last if $line[0] eq 'what';
      }

   die "Could not find leading 'what' in '$inf'" if ($line[0] ne 'what');

   my $np = 1;
   my @keys;

   while ($line = <IN>) {
      chomp($line);
      my @l = split(',', $line);

      $np = $l[1]      if ($l[0] eq 'nproc');
      @keys = @l, last if ($l[0] eq 'size');
      }

   # $line = <IN>; chomp($line); my ($t_nproc, $np) = split(',', $line);
   # $line = <IN>; chomp($line); my @keys           = split(',', $line);
   # die 'expected "nproc" on line 2' if ($t_nproc ne "nproc");

   # my $k = "$bench-$case-$np";
   my $k = "$inf";
   $k =~ s/\.dat//;

   $db->{$k}       = {};
   $db->{$k}{data} = {};
   $db->{$k}{file} = $inf;

   # print "$inf: $k\n";

   while (<IN>) {
      chomp($_);
      last if /^--/;

      my @line = split(',', $_);

      my $record = {size    => $line[0] + 0,
		    med     => $line[1],
		    min     => $line[2],
		    max     => $line[3],
		    mem_pt  => $line[4],
		    ops_pt  => $line[5],
		    riob_pt => $line[6],
		    wiob_pt => $line[7],
		    loop    => $line[8],
		    time    => $line[9]};

      my $size    = $line[0] + 0;
      my $med     = $line[1];
      my $min     = $line[2];
      my $max     = $line[3];
      my $mem_pt  = $line[4];
      my $ops_pt  = $line[5];
      my $riob_pt = $line[6];
      my $wiob_pt = $line[7];
      my $loop    = $line[8];
      my $time    = $line[9];
     
      $db->{$k}{data}{$size} = $record;
      }
   close(IN);
   }


sub report_func {
   my ($db, $k, $descr, %opt) = @_;

   my $metric   = $opt{metric}   || "mflop_s";
   my $timeunit = $opt{timeunit} || "us";
   my $rows     = $opt{rows}     || 1;

   my $sizes  = $opt{sizes}  || [1024, 8192];

   my @sizes = @$sizes;

   return if (!defined $db->{$k} && $opt{optional});

   if ($sheet) {
      if (!defined $db->{$k}) {
	return;
	}
      }
   print OUT "$descr\n";
   if (!defined $db->{$k}) {
      print OUT "   (not generated)\n\n";
      return;
      }

   my $time_factor = 1;
   $time_factor = 1       if $timeunit eq 'us';
   $time_factor = 1000    if $timeunit eq 'ms';
   $time_factor = 1000000 if $timeunit eq 's';

   printf OUT "  %5s  %7s  %7s", "Size", "$timeunit/call", "$timeunit/pt";

   foreach my $m (split(/[, ]/, $metric)) {
      my $x_name;
      $x_name = "MFLOP/s" if ($m eq 'mflop_s');
      $x_name = "MOP/s"   if ($m eq 'mop_s');
      $x_name = "R MB/s"  if ($m eq 'r_mb_s');
      $x_name = "W MB/s"  if ($m eq 'w_mb_s');
      $x_name = "T MB/s"  if ($m eq 't_mb_s');
      $x_name = "Mpt/s"   if ($m eq 'mpts_s');
      next                if ($m eq 'none');
      printf OUT "  %8s", $x_name;
      }
   printf OUT "\n";
   # printf OUT "  %5s  %7s  %7s  %8s\n", "", "(usec)", "(usec)", "";

   foreach my $size (@sizes) {
      my $mpts_s  = $db->{$k}{data}{$size}{med};	# median Mpts-sec
      my $ops_pt  = $db->{$k}{data}{$size}{ops_pt};
      my $riob_pt = $db->{$k}{data}{$size}{riob_pt};
      my $wiob_pt = $db->{$k}{data}{$size}{wiob_pt};
      my $us_pt   = ($mpts_s == 0) ? 0 : 1 / $mpts_s; # sec/M-point aka usec/point

      $us_pt /= $time_factor;

      my $s       = $size * $us_pt;

      my $mflop_s = $mpts_s * $ops_pt;
      my $mop_s   = $mpts_s * $ops_pt;
      my $r_mb_s  = $mpts_s * $riob_pt;
      my $w_mb_s  = $mpts_s * $wiob_pt;
      my $t_mb_s  = $mpts_s * ($riob_pt + $wiob_pt);

      # For 2D object, users like to think of point as 1,1 element,
      # rather than a column of elements.
      $us_pt /= $rows;

      if ($size >= 1048576) {
	 printf OUT "  %4.2f%s", ($size / 1048576), "M";
	 }
      else {
	 printf OUT "  %5d", $size;
	 }

      my $s_str = sprintf "%7.1f", $s;
      if (length($s_str) > 7) {
	$s_str = sprintf "%7f", $s;
	}
      if (length($s_str) > 7) {
	$s_str = sprintf "%7.2g", $s;
	}

      my $us_pt_str = sprintf "%7.5f", $us_pt;
      if (length($us_pt_str) > 7) {
	$us_pt_str = sprintf "%7f", $us_pt;
	}
      if (length($us_pt_str) > 7) {
	$us_pt_str = sprintf "%7.2g", $us_pt;
	}

      printf OUT "  %7s  %7s", $s_str, $us_pt_str;

      foreach my $m (split(/[, ]/, $metric)) {
	 my $x;
	 $x = $mflop_s if ($m eq 'mflop_s');
	 $x = $mop_s   if ($m eq 'mop_s');
	 $x = $r_mb_s  if ($m eq 'r_mb_s');
	 $x = $w_mb_s  if ($m eq 'w_mb_s');
	 $x = $t_mb_s  if ($m eq 't_mb_s');
	 $x = $mpts_s  if ($m eq 'mpts_s');
	 next          if ($m eq 'none');
	 printf OUT "  %8.2f", $x;
	 }
      printf OUT "\n";
      }
   print OUT "\n";
   }



sub report_func_csv {
   my ($db, $k, $descr, %opt) = @_;

   my $metric = $opt{metric} || "mflop_s";
   my $rows   = $opt{rows}   || 1;

   my $sizes  = $opt{sizes}  || [1024, 8192];

   my @sizes = @$sizes;

   return if (!defined $db->{$k} && $opt{optional});

   $descr =~ s/,/\\\,/g;

   if (!defined $db->{$k}) {
      foreach my $size (@sizes) {
	 printf OUT "\"$descr\", $k, $size\n";
	 }
      return;
      }

   foreach my $size (@sizes) {
      my $mpts_s  = $db->{$k}{data}{$size}{med};	# median Mpts-sec
      my $ops_pt  = $db->{$k}{data}{$size}{ops_pt};
      my $riob_pt = $db->{$k}{data}{$size}{riob_pt};
      my $wiob_pt = $db->{$k}{data}{$size}{wiob_pt};
      my $us_pt   = ($mpts_s == 0) ? 0 : 1 / $mpts_s; # sec/M-point aka usec/point
      my $s       = $size * $us_pt;

      my $mflop_s = $mpts_s * $ops_pt;
      my $r_mb_s  = $mpts_s * $riob_pt;
      my $w_mb_s  = $mpts_s * $wiob_pt;
      my $t_mb_s  = $mpts_s * ($riob_pt + $wiob_pt);

      # For 2D object, users like to think of point as 1,1 element,
      # rather than a column of elements.
      $us_pt /= $rows;

      printf OUT "\"$descr\", $k, $size, $s, $us_pt, $mflop_s, $r_mb_s, $w_mb_s, $t_mb_s, $mpts_s\n";
      }
   }


sub header {
   my ($name) = @_;

   print  OUT "\n";
   print  OUT "=" x 73, "\n";
   printf OUT "= %-69s =\n", $name;
   print  OUT "=" x 73, "\n";
   print  OUT "\n";
   }



# --------------------------------------------------------------------- #
sub read_db {
   my ($db, $macro, $order, $file) = @_;

   my $scnt = 0;

   open(FILE, $file) || die "Can't read '$file': $!\n";

   while (<FILE>) {
      if (/^set:\s*([\w_\d\-]+)/) {
	 my $set = $1;
	 push @$order, $set;
	 $db->{$set} = {};
	 while (<FILE>) {
            last if /^\s*$/;
	    if (/\s+(\w+):\s*(.+)$/) {
	       $db->{$set}{$1} = $2;
	       }
	    }
	 }
      elsif (/^section:\s*(.+)/) {
	 my $set = "section-$scnt";
	 $scnt++;
	 push @$order, $set;
	 $db->{$set} = {};
	 $db->{$set}{header} = $1;
	 }
	       
      elsif (/^macro:\s*([\w-]+)\s+(.+)$/) {
	 $macro->{$1} = [split(/\s+/, $2)];
	 }
      }
   close(FILE);

   return $db, $macro;
}

my $dsinfo = "/home/jules/ds.info";
my $fmt    = "text";
my $ofile  = "report";

while (@ARGV) {
   my $arg = shift @ARGV;
   
   $sheet  = 1, next if ($arg eq '-sheet');
   $dsinfo = shift @ARGV, next if ($arg eq '-db');
   $fmt    = shift @ARGV, next if ($arg eq '-fmt');
   $ofile  = shift @ARGV, next if ($arg eq '-o');
   }

if (!-f $dsinfo) {
   die "ERROR: Can't find dsinfo '$dsinfo'\n";
   }

my $db = {};
my $descr = {};
my $macro = {};
my $order = [];
print "read_db: $dsinfo\n";
read_db($descr, $macro, $order, $dsinfo);

foreach my $k (keys %$descr) {
   next if $descr->{$k}{header};
   my $inf = "$k.dat";
   if (!-f $inf) {
      print "No $inf, SKIPPING\n" if (!$descr->{$k}{optional});
      next;
      }
   read_dat($db, $inf);
   }

open(OUT, "> $ofile");
if ($fmt eq 'csv') {
   printf OUT "descr, k, size, time (s), us/pt, MF/s, R MB/s, W MB/s, T MB/s, MPt/s\n";
   }

foreach my $k (@$order) {
   my @opt;

   if ($descr->{$k}{header}) {
      header($descr->{$k}{header}) if (!$sheet && $fmt ne 'csv');
      next;
      }

   if ($descr->{$k}{sizes}) {
      push @opt, sizes => [split(/[, ]/, $descr->{$k}{sizes})];
      }
   if ($descr->{$k}{metric}) {
      push @opt, metric => $descr->{$k}{metric};
      }
   if ($descr->{$k}{timeunit}) {
      push @opt, timeunit => $descr->{$k}{timeunit};
      }
   if ($descr->{$k}{optional}) {
      push @opt, optional => $descr->{$k}{optional};
      }
   if ($fmt eq 'csv') {
      report_func_csv($db, $k, $descr->{$k}{text}, @opt);
      }
   else {
      report_func($db, $k, $descr->{$k}{text} . "  ($k)", @opt);
      }
   }
close(OUT);
